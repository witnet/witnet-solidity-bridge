// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import {
    Witnet, 
    WitRandomness, 
    IWitRandomness
} from "../WitRandomness.sol";

abstract contract UsingWitRandomness {
    WitRandomness immutable public WIT_RANDOMNESS;
    
    constructor (address randomizer) {
        assert(
            randomizer.code.length > 0
                && WitRandomness(randomizer).specs() == type(IWitRandomness).interfaceId
        );
        WIT_RANDOMNESS = WitRandomness(randomizer);    
    }

    /// Retrieves the result of keccak256-hashing the specified block number with the randomness value 
    /// generated by the Witnet blockchain in response to the first non-failing randomize request solved 
    /// after such block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on the `WIT_RANDOMNESS` contract for neither the specified block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the specified block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the specified block were solved with errors.
    function _fetchRandomnessAfter(uint256 _blockNumber) virtual internal view returns (bytes32) {
        return keccak256(
            abi.encode(
                WIT_RANDOMNESS.fetchRandomnessAfter(_blockNumber),
                address(this)
            )
        );
    }

    /// Generates a pseudo-random number uniformly distributed within the range [0 .. _faces), 
    /// by using the specified `_nonce` and `_seed`.
    /// @dev Fails under same conditions as `_fetchRandomnessAfter(uint256)` does.
    function _rollTheDice(uint64 _faces, uint256 _nonce, bytes32 _seed) internal pure returns (uint64) {
        return Witnet.randomUniformUint64(
            _faces,
            _nonce,
            _seed
        );
    }
}
