// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import {
    Witnet, 
    WitRandomness, 
    IWitRandomness
} from "./WitRandomness.sol";

abstract contract UsingWitRandomness {
    WitRandomness immutable public WIT_RANDOMNESS;
    
    constructor (address randomizer) {
        assert(
            randomizer.code.length > 0
                && WitRandomness(randomizer).specs() == type(IWitRandomness).interfaceId
        );
        WIT_RANDOMNESS = WitRandomness(randomizer);    
    }

    /// @notice Retrieves the result of keccak256-hashing the specified block number with the randomness value 
    /// generated by the Witnet blockchain in response to the first non-failing randomize request solved 
    /// after such block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on the `WIT_RANDOMNESS` contract for neither the specified block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the specified block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the specified block were solved with errors.
    function _fetchRandomnessAfter(uint256 _blockNumber) virtual internal view returns (bytes32) {
        return keccak256(
            abi.encode(
                WIT_RANDOMNESS.fetchRandomnessAfter(_blockNumber),
                address(this)
            )
        );
    }

    /// @notice Generates a pseudo-random number uniformly distributed within the range [0 .. _faces), 
    /// by using the specified `_nonce` and `_seed`.
    /// @dev Fails under same conditions as `_fetchRandomnessAfter(uint256)` does.
    function _randomDice(uint64 _faces, uint256 _nonce, bytes32 _seed) internal pure returns (uint64) {
        return Witnet.randomUniformUint64(
            _faces,
            _nonce,
            _seed
        );
    }

    /// @notice Generates a pseudo-random uniformly distributed extraction, with repetitions. 
    function _randomExtractionWithReps(
            uint64  _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (uint64[] memory _balls)
    {
        unchecked {
            _balls = new uint64[](_extractions);
            for (uint16 _ix; _ix < _extractions; _ix ++) {
                _balls[_ix] = Witnet.randomUniformUint64(
                    _range, 
                    _ix, 
                    _seed
                );
            }
        }
    }

    /// @notice Generates a pseudo-random uniformly distributed extraction, with no repetitions. 
    function _randomExtractionNoReps(
            uint64  _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (uint64[] memory _balls)
    {
        unchecked {
            uint64[] memory _numbers = new uint64[](_range);
            for (uint64 _ix; _ix < _range; _ix ++) {
                _numbers[_ix] = _ix;
            }
            _balls = new uint64[](_extractions);
            for (uint16 _jx; _jx < _extractions; _jx ++) {
                uint64 _pos = Witnet.randomUniformUint64(
                    _range - _jx, 
                    _jx, 
                    _seed
                );
                _balls[_jx] = _numbers[_pos];
                _numbers[_pos] = _numbers[_range - 1 - _jx];
            }
        }
    }
}
