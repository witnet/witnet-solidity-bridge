// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import {
    Witnet, 
    WitRandomness, 
    IWitRandomness,
    IWitRandomnessEvents
} from "./WitRandomness.sol";

abstract contract UsingWitRandomness
    is
        IWitRandomnessEvents
{
    WitRandomness immutable internal __witRandomness;

    /// @dev Provides a way for blocking execution of business logic if no Witnet-certified
    /// randomness has yet been provided for the specified block number.
    modifier blockIsRandomized(uint256 _evmBlockNumber) {
        require(
            __witRandomness.isRandomized(_evmBlockNumber),
            "UsingWitRandomness: pending randomize"
        ); _;
    }
    
    constructor (address randomizer) {
        require(
            randomizer != address(0)
                && randomizer.code.length > 0
                && WitRandomness(randomizer).specs() == type(IWitRandomness).interfaceId,
            "UsingWitRandomness: uncompliant WitRandomness"            
        );
        __witRandomness = WitRandomness(randomizer);
    }

    /// @dev Estimate the minimum randomize fee to pay if willing to actively pull a new randomize request.
    function _estimateRandomizeFee() virtual internal view returns (uint256) {
        return _estimateRandomizeFee(tx.gasprice);
    }

    /// @dev Estimate the minimum randomize fee to pay if willing to actively pull a new randomize request.
    function _estimateRandomizeFee(uint256 _evmGasPrice) virtual internal view returns (uint256) {
        return __witRandomness.estimateRandomizeFee(_evmGasPrice);
    }

    /// @notice Retrieves the result of keccak256-hashing the specified block number with the randomness value 
    /// generated by the Witnet blockchain in response to the first non-failing randomize request solved 
    /// after such block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on the `WIT_RANDOMNESS` contract for neither the specified block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the specified block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the specified block were solved with errors.
    function _fetchRandomnessAfter(uint256 _blockNumber) virtual internal view returns (bytes32) {
        return keccak256(
            abi.encode(
                __witRandomness.fetchRandomnessAfter(_blockNumber),
                address(this)
            )
        );
    }

    /// @notice Generates a pseudo-random number uniformly distributed within the range [0 .. _faces), 
    /// by using the specified `_nonce` and `_seed`.
    /// @dev Fails under same conditions as `_fetchRandomnessAfter(uint256)` does.
    function _generateUniformDice(uint64 _faces, uint256 _nonce, bytes32 _seed) internal pure returns (uint64) {
        return Witnet.randomUniformUint64(
            _faces,
            _nonce,
            _seed
        );
    }

    /// @notice Generates a pseudo-random uniformly distributed extraction, with repetitions. 
    function _generateUniformExtractionWithReps(
            uint64  _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (uint64[] memory _balls)
    {
        unchecked {
            _balls = new uint64[](_extractions);
            for (uint16 _ix; _ix < _extractions; _ix ++) {
                _balls[_ix] = Witnet.randomUniformUint64(
                    _range, 
                    _ix, 
                    _seed
                );
            }
        }
    }

    /// @notice Generates a pseudo-random uniformly distributed extraction, with no repetitions. 
    function _generateUniformExtractionNoReps(
            uint64  _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (uint64[] memory _balls)
    {
        unchecked {
            uint64[] memory _numbers = new uint64[](_range);
            for (uint64 _ix; _ix < _range; _ix ++) {
                _numbers[_ix] = _ix;
            }
            _balls = new uint64[](_extractions);
            for (uint16 _jx; _jx < _extractions; _jx ++) {
                uint64 _pos = Witnet.randomUniformUint64(
                    _range - _jx, 
                    _jx, 
                    _seed
                );
                _balls[_jx] = _numbers[_pos];
                _numbers[_pos] = _numbers[_range - 1 - _jx];
            }
        }
    }

    /// @notice Reference to the underlying Wit/Oracle Framework.
    function witOracle() virtual public view returns (address) {
        return __witRandomness.witOracle();
    }
}
