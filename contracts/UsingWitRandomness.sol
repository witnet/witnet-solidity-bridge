// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import "./WitRandomness.sol";

abstract contract UsingWitRandomness
    is
        IWitRandomnessEvents
{
    WitRandomness immutable internal __witRandomness;

    /// @dev Provides a way for blocking execution of business logic if no Witnet-certified
    /// randomness has yet been provided for the specified block number.
    modifier blockIsRandomized(uint256 _evmBlockNumber) {
        require(
            __witRandomness.isRandomized(_evmBlockNumber),
            "UsingWitRandomness: pending randomize"
        ); _;
    }

    /// @dev On contracts implementing `IWitRandomnessConsumer`, provides a way to verify
    /// that the contract reporting Witnet-certified randomness is legit:
    modifier onlyFromWitnet {
        require(
            msg.sender == address(__witRandomness),
            "UsingWitRandomness: invalid randomizer"
        ); _;
    }
    
    constructor (IWitRandomness randomizer) {
        require(
            address(randomizer) != address(0)
                && address(randomizer).code.length > 0
                && WitRandomness(address(randomizer)).specs() == type(IWitRandomness).interfaceId,
            "UsingWitRandomness: uncompliant WitRandomness"            
        );
        __witRandomness = WitRandomness(address(randomizer));
    }

    /// @notice Reference to the underlying Wit/Oracle Framework.
    function witOracle() virtual public view returns (address) {
        return __witRandomness.witOracle();
    }

    /// @dev Estimate the minimum randomize fee to pay if willing to actively pull a new randomize request.
    function _estimateRandomizeFee() virtual internal view returns (uint256) {
        return _estimateRandomizeFee(tx.gasprice);
    }

    /// @dev Estimate the minimum randomize fee to pay if willing to actively pull a new randomize request.
    function _estimateRandomizeFee(uint256 _evmGasPrice) virtual internal view returns (uint256) {
        return __witRandomness.estimateRandomizeFee(_evmGasPrice);
    }

    /// @notice Retrieves the result of keccak256-hashing the specified block number with the randomness value 
    /// generated by the Witnet blockchain in response to the first non-failing randomize request solved 
    /// after such block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on the `WIT_RANDOMNESS` contract for neither the specified block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the specified block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the specified block were solved with errors.
    function _fetchRandomnessAfter(uint256 _blockNumber) virtual internal view returns (bytes32) {
        return keccak256(
            abi.encode(
                __witRandomness.fetchRandomnessAfter(_blockNumber),
                address(this)
            )
        );
    }


    /// ===============================================================================================================
    /// --- Internal helper pure methods ------------------------------------------------------------------------------

    /// @notice Generates a pseudo-random number uniformly distributed within the range [0 .. _faces), 
    /// by using the specified `_nonce` and `_seed`.
    function _castADice(uint8 _faces, uint256 _nonce, bytes32 _seed) internal pure returns (uint8) {
        return uint8(Witnet.randomUniformUint64(
            _faces,
            _nonce,
            _seed
        ));
    }

    function _castALargeDice(uint64 _faces, uint256 _nonce, bytes32 _seed) internal pure returns (uint64) {
        return Witnet.randomUniformUint64(
            _faces,
            _nonce,
            _seed
        );
    }
    

    /// @notice Generates a pseudo-random uniformly distributed extraction, with repetitions. 
    function _generateExtractionWithReps(
            uint8   _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (bytes memory _balls)
    {
        unchecked {
            _balls = new bytes(_extractions);
            for (uint16 _ix; _ix < _extractions; _ix ++) {
                _balls[_ix] = bytes1(uint8(Witnet.randomUniformUint64(
                    _range, 
                    _ix, 
                    _seed
                )));
            }
        }
    }
    function _generateLargeExtractionWithReps(
            uint64  _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (uint64[] memory _balls)
    {
        unchecked {
            _balls = new uint64[](_extractions);
            for (uint16 _ix; _ix < _extractions; _ix ++) {
                _balls[_ix] = Witnet.randomUniformUint64(
                    _range, 
                    _ix, 
                    _seed
                );
            }
        }
    }

    /// @notice Generates a pseudo-random uniformly distributed extraction, with no repetitions. 
    function _generateExtractionNoReps(
            uint8   _range,
            uint8   _extractions,
            bytes32 _seed
        )
        internal pure
        returns (bytes memory _balls)
    {
        unchecked {
            bytes memory _numbers = new bytes(_range);
            for (uint8 _ix; _ix < _range; _ix ++) {
                _numbers[_ix] = bytes1(_ix);
            }
            _balls = new bytes(_extractions);
            for (uint8 _jx; _jx < _extractions; _jx ++) {
                uint8 _pos = uint8(Witnet.randomUniformUint64(
                    _range - _jx, 
                    _jx, 
                    _seed
                ));
                _balls[_jx] = _numbers[_pos];
                _numbers[_pos] = _numbers[_range - 1 - _jx];
            }
        }
    }
    function _generateLargeExtractionNoReps(
            uint64  _range, 
            uint16  _extractions, 
            bytes32 _seed
        )
        internal pure
        returns (uint64[] memory _balls)
    {
        unchecked {
            uint64[] memory _numbers = new uint64[](_range);
            for (uint64 _ix; _ix < _range; _ix ++) {
                _numbers[_ix] = _ix;
            }
            _balls = new uint64[](_extractions);
            for (uint16 _jx; _jx < _extractions; _jx ++) {
                uint64 _pos = Witnet.randomUniformUint64(
                    _range - _jx, 
                    _jx, 
                    _seed
                );
                _balls[_jx] = _numbers[_pos];
                _numbers[_pos] = _numbers[_range - 1 - _jx];
            }
        }
    }
}
