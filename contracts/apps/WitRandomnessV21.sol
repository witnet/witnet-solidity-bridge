// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import "../WitRandomness.sol";
import "../interfaces/IWitRandomnessAdmin.sol";
import "../mockups/UsingWitOracle.sol";
import "../patterns/Ownable2Step.sol";

/// @title WitRandomnessV21: Unbiased, EVM-agnostic and provably-fair random seeds from the Witnet blockchain. 
/// 
/// 256-bit random seeds can be permissionless pulled at anytime from smart contracts and externally-owned EVM accounts.
/// 
/// Randomness provisioning is securely protected against race-condition and malleability attacks by node validators
/// on both EVM and Witnet blockchains. 
///
/// This contract acts also as a public-good registry, openly preserving all random seeds generated in the past,
/// and providing after-the-fact traceability proof to the actual witnessing committees and punishable acts that took
/// place on the Witnet blockchain for generating every single one of them.
///
/// @dev Protection against race-condition and malleability attacks requires randomness queried to this contract
/// to be solved is an asynchronous way, meaning that after some randomness is requested, the result provided
/// from the Wit/Oracle sidechain won't be ready until a certain amount of EVM blocks have elapsed. 
/// This protection also implies that eventually failing randomness requests on the Wit/Oracle sidechain 
/// cannot be retried but from this very same contract. Failing randomness requests will get all automatically
/// and unbiasedly solved as soon as some new randomness request gets solved, even if paid by a different requester.
///
/// Querying for new randomness requires paying a fee in native EVM gas currency, as to cover the implicit cost of
/// solving unmalleable randomness on the Wit/Oracle sidechain and report it back to the EVM storage. The actual 
/// randomize fee depends on the expected gas price to pay for the EVM transaction that would eventually include 
/// a call to any of the `randomize(..)` methods of this contract. The randomize fee can be computed by passing
/// the expected gas price value to the `estimateRandomizeFee(uint256)` method.
///
/// > Note [1]: On highly volatile gas price markets, especially on some Layer-2 EVM chains, is highly recommended
/// to estimate the randomize fee before a `randomize()` call, and pass a fresh EVM gas price value. Otherwise
/// the call to `randomize()` could potentially revert with either "insufficient reward" or "too much reward".
///
/// > Note [2]: Contracts requiring "synchronous" randomness resolution (e.g. minting NFTs) as to avoid
/// involving end users in two-phase operations, might rather prefer to inherit from the 
/// `WitOracleQueriableRandomnessConsumer` abstract class instead of relying on this contract. Nevertheless,
/// they would have to deal themselves with eventual randomness resolution errors.
///
/// @author Guillermo DÃ­az <guillermo@witnet.io>
contract WitRandomnessV21
    is
        Ownable2Step,
        UsingWitOracle,
        WitRandomness,
        IWitRandomnessAdmin
{
    using Witnet for bytes;
    using Witnet for uint64;
    using Witnet for Witnet.DataResult;
    using Witnet for Witnet.QueryId;
    using Witnet for Witnet.QuerySLA;
    using Witnet for Witnet.ResultStatus;

    struct Randomize {
        Witnet.QueryId queryId;
        uint96 prevEvmBlock;
        uint96 nextEvmBlock;
    }

    struct Storage {
        uint256 lastRandomizeBlock;
        mapping (uint256 => Randomize) randomize_;
        IWitRandomnessAdmin.WitParams requiredWitParams;
    }
    
    /// @notice Unique identifier of the RNG data request used on the Witnet blockchain for solving randomness.
    /// @dev Can be used to track all randomness requests solved so far on the Witnet blockchain.
    Witnet.RadonHash internal immutable __witOracleQueryRadonHash;

    /// @dev Size of successful CBOR-encoded randomness generated by the Witnet blockchain. 
    uint16 internal constant _WIT_QUERY_MAX_RESULT_SIZE = 34;

    constructor(
            address _witOracle,
            address _operator
        )
        Ownable(_operator)
        UsingWitOracle(_witOracle)
    {
        // Build Witnet-compliant randomness request:
        IWitOracleRadonRegistry _registry = IWitOracle(witOracle()).registry();
        __witOracleQueryRadonHash = _registry.verifyRadonRequest(
            Witnet.intoMemArray([
                _registry.verifyRadonRetrieval(
                    Witnet.RadonRetrievalMethods.RNG,
                    "", // no request url
                    "", // no request body
                    new string[2][](0), // no request headers
                    hex"80" // no request Radon script
                )
            ]),
            Witnet.RadonReducer({
                opcode: Witnet.RadonReduceOpcodes.Mode,
                filters: new Witnet.RadonFilter[](0)
            }),
            Witnet.RadonReducer({
                opcode: Witnet.RadonReduceOpcodes.ConcatenateAndHash,
                filters: new Witnet.RadonFilter[](0)
            })
        );
        __witOracleDefaultQueryParams.witResultMaxSize = _WIT_QUERY_MAX_RESULT_SIZE;
        __storage().requiredWitParams = IWitRandomnessAdmin.WitParams({
            minWitInclusionFees: __witOracleDefaultQueryParams.witUnitaryReward,
            minWitCommitteeSize: __witOracleDefaultQueryParams.witCommitteeSize
        });
    }

    receive() virtual external payable {
        _revert("no transfers accepted");
    }

    fallback() virtual external payable { 
        _revert(string(abi.encodePacked(
            "not implemented: 0x",
            Witnet.toHexString(uint8(bytes1(msg.sig))),
            Witnet.toHexString(uint8(bytes1(msg.sig << 8))),
            Witnet.toHexString(uint8(bytes1(msg.sig << 16))),
            Witnet.toHexString(uint8(bytes1(msg.sig << 24)))
        )));
    }

    function class() virtual override public pure returns (string memory) {
        return type(WitRandomnessV21).name;
    }

    function witOracle() override (IWitOracleAppliance, UsingWitOracle)
        public view returns (address)
    {
        return UsingWitOracle.witOracle();
    }

    
    /// ===============================================================================================================
    /// --- 'IWitRandomness' implementation ---------------------------------------------------------------------------

    /// Returns amount of wei required to be paid as a fee when requesting randomization with a 
    /// transaction gas price as the one given.
    function estimateRandomizeFee(uint256 _evmGasPrice)
        public view
        virtual override
        returns (uint256)
    {
        return (
            __witOracle.estimateBaseFee(_evmGasPrice) 
                * (100 + __witOracleBaseFeeOverheadPercentage)
        ) / 100;
    }

    /// @notice Retrieves the result of keccak256-hashing the given block number with the randomness value 
    /// generated by the Witnet blockchain in response to the first non-failing randomize request solved 
    /// after such block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on neither the given block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the given block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the given block were solved with errors.
    ///
    /// @param _evmBlockNumber Block number from which the search will start.
    function fetchRandomnessAfter(uint256 _evmBlockNumber)
        public view
        virtual override
        returns (bytes32)
    {
        return keccak256(
            abi.encode(
                _evmBlockNumber,
                _fetchRandomnessAfter(_evmBlockNumber)
            )
        );
    }
    
    /// @notice Retrieves the actual random value, unique hash and timestamp of the witnessing commit/reveal act 
    /// that took place in the Witnet blockchain in response to the first non-failing randomize query
    /// solved after the given block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on neither the given block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the given block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the given block were solved with errors.
    ///
    /// @param _evmBlockNumber Block number from which the search will start.
    ///
    /// @return _witnetQueryUUID Identifier of the query, posted from this contract, that ultimately solved randomness.
    /// @return _witnetDrTxHash Hash of the witnessing commit/reveal act that took place on the Witnet blockchain.
    /// @return _witnetTimestamp Timestamp at which the randomness value was generated by the Witnet blockchain.
    /// @return _evmFinalityBlock EVM block number at which the generated randomness can be considered to be final.
    function fetchRandomnessAfterProof(uint256 _evmBlockNumber) 
        virtual override
        public view 
        returns (
            bytes32 _witnetQueryUUID,
            Witnet.TransactionHash _witnetDrTxHash,
            Witnet.Timestamp _witnetTimestamp,
            uint256 _evmFinalityBlock
        )
    {
        (_witnetQueryUUID, _witnetDrTxHash, _witnetTimestamp, _evmFinalityBlock) = __witOracle.getQueryResultTrails(
            Witnet.QueryId.unwrap(
                _fetchRandomizeValidResultQueryId(_evmBlockNumber)
            )
        );
    }

    /// @notice Returns last block number on which a randomize was requested.
    function getLastRandomizeBlock()
        virtual override
        external view
        returns (uint256)
    {
        return __storage().lastRandomizeBlock;
    }

    /// @notice Retrieves metadata related to the randomize request that got queried to the`WitOracle` contract 
    /// on the specified block number, if any.
    ///
    /// @dev Returns zero values if no randomize request was actually queried on the specified block number.
    ///
    /// @param _evmBlockNumber Block number from which the search will start.
    ///
    /// @return _queryId Identifier of the underlying Wit/Oracle query created on the specified block number. 
    /// @return _prevRandomizeBlock Block number in which a randomize request got queried just before this one. 0 if none.
    /// @return _nextRandomizeBlock Block number in which a randomize request got queried just after this one, 0 if none.
    function getRandomizeData(uint256 _evmBlockNumber)
        external view
        virtual override
        returns (
            uint256 _queryId,
            uint256 _prevRandomizeBlock,
            uint256 _nextRandomizeBlock
        )
    {
        Randomize memory _randomize = __storage().randomize_[_evmBlockNumber];
        _queryId = Witnet.QueryId.unwrap(_randomize.queryId);
        _prevRandomizeBlock = _randomize.prevEvmBlock;
        _nextRandomizeBlock = _randomize.nextEvmBlock;
    }

    /// @notice Returns security and liveness parameters required to the Witnet blockchain 
    /// when solving randomness requests, if no others are specified.
    /// @param _witCommitteeSize Number of Wit/Oracle nodes contributing to unbiased randomness.
    /// @param _witInclusionFees Minimum amount of fees in $nanoWIT to be paid on the Witnet blockchain
    function getRandomizeDefaultParams() 
        virtual override
        public view
        returns (
            uint16 _witCommitteeSize,
            uint64 _witInclusionFees
        )
    {
        Witnet.QuerySLA memory _defaultQuerySLA = __witOracleDefaultQueryParams;
        _witCommitteeSize = _defaultQuerySLA.witCommitteeSize;
        _witInclusionFees = _defaultQuerySLA.witUnitaryReward;
    }

    /// @notice Returns the number of the next block in which a randomize request was posted after the given one. 
    /// @param _evmBlockNumber Block number from which the search will start.
    /// @return Number of the first block found after the given one, or `0` otherwise.
    function getRandomizeNextBlock(uint256 _evmBlockNumber)
        public view
        virtual override
        returns (uint256)
    {
        return (__storage().randomize_[_evmBlockNumber].queryId.isZero()
            ? _searchNextBlock(_evmBlockNumber, __storage().lastRandomizeBlock)
            : __storage().randomize_[_evmBlockNumber].nextEvmBlock
        );
    }

    /// @notice Returns the number of the previous block in which a randomize request was posted before the given one.
    /// @param _evmBlockNumber Block number from which the search will start. Cannot be zero.
    /// @return First block found before the given one, or `0` otherwise.
    function getRandomizePrevBlock(uint256 _evmBlockNumber)
        public view
        virtual override
        returns (uint256)
    {
        uint256 _latest = __storage().lastRandomizeBlock;
        return (_evmBlockNumber > _latest
            ? _latest
            // start search from the latest block
            : _searchPrevBlock(_evmBlockNumber, __storage().randomize_[_latest].prevEvmBlock)
        );
    }

    /// @notice Returns the bytecode of the Radon Request used for solving
    /// randomness requests on the Witnet blockchain.
    function getRandomizeRadonBytecode() virtual override external view returns (bytes memory) {
        return IWitOracle(witOracle()).registry().lookupRadonRequestBytecode(
            getRandomizeRadonHash()
        );
    }

    /// @notice Returns the unique identifier of the Radon Request used for solving 
    /// request randomness requests on the Witnet blockchain.
    function getRandomizeRadonHash() virtual override public view returns (Witnet.RadonHash) {
        return __witOracleQueryRadonHash;
    }

    /// @notice Returns status of the first non-errored randomize request queried on or after the given block number.
    ///  - 0 -> Void: no randomize request was actually queried on or after the given block number.
    ///  - 1 -> Awaiting: a randomize request was found but it's not yet solved by the Wit/Oracle.
    ///  - 2 -> Ready: a successfull randomize value was reported and is ready to be read.
    ///  - 3 -> Error: all attempted randomize requests at or after the given block were solved with errors.
    ///  - 4 -> Finalizing: a randomize result was relayed already but cannot yet be considered to be final.
    function getRandomizeStatus(uint256 _evmBlockNumber)
        virtual override
        public view 
        returns (RandomizeStatus)
    {
        if (__storage().randomize_[_evmBlockNumber].queryId.isZero()) {
            _evmBlockNumber = getRandomizeNextBlock(_evmBlockNumber);
        }
        uint256 _queryId = Witnet.QueryId.unwrap(__storage().randomize_[_evmBlockNumber].queryId);
        if (_queryId == 0) {
            return RandomizeStatus.Void;
        }
        Witnet.ResultStatus _status = __witOracle.getQueryResultStatus(_queryId);
        if (_status == Witnet.ResultStatus.BoardAwaitingResult) {
            return RandomizeStatus.Awaiting;
        
        } else if (_status == Witnet.ResultStatus.BoardFinalizingResult) {
            return RandomizeStatus.Finalizing;

        } else if (_status == Witnet.ResultStatus.NoErrors) {
            return RandomizeStatus.Ready;
        
        } else {
            uint256 _nextRandomizeBlock = __storage().randomize_[_evmBlockNumber].nextEvmBlock;
            if (_nextRandomizeBlock != 0) {
                return getRandomizeStatus(_nextRandomizeBlock);
            } else {
                return RandomizeStatus.Error;
            }
        }
    }

    function getRandomizeStatusDescription(uint256 _evmBlockNumber) 
        virtual override 
        public view
        returns (string memory)
    {
        if (__storage().randomize_[_evmBlockNumber].queryId.isZero()) {
            _evmBlockNumber = getRandomizeNextBlock(_evmBlockNumber);
        }
        uint256 _queryId = Witnet.QueryId.unwrap(__storage().randomize_[_evmBlockNumber].queryId);
        if (_queryId == 0) {
            return string(abi.encodePacked(
                "No randomize after block #",
                Witnet.toString(_evmBlockNumber)
            ));
        }
        Witnet.ResultStatus _status = __witOracle.getQueryResultStatus(_queryId);
        if (_status == Witnet.ResultStatus.BoardAwaitingResult) {
            return string(abi.encodePacked(
                "Randomize posted as for block #",
                Witnet.toString(_evmBlockNumber)
            ));
        
        } else if (_status == Witnet.ResultStatus.BoardFinalizingResult) {
            return string(abi.encodePacked(
                "Finalizing randomize as for block #",
                Witnet.toString(_evmBlockNumber)
            ));

        } else if (_status == Witnet.ResultStatus.NoErrors) {
            return string(abi.encodePacked(
                "Randomize result ready as for block #",
                Witnet.toString(_evmBlockNumber)
            ));
        
        } else {
            uint256 _nextRandomizeBlock = __storage().randomize_[_evmBlockNumber].nextEvmBlock;
            if (_nextRandomizeBlock != 0) {
                return getRandomizeStatusDescription(_nextRandomizeBlock);
            
            } else {
                return string(abi.encodePacked(
                    "Randomize failed as for block #",
                    Witnet.toString(_evmBlockNumber),
                    ": ",
                    __witOracle.getQueryResultStatusDescription(_queryId)
                ));
            }
        }
    }

    /// @notice Returns `true` only if a successfull resolution from the Witnet blockchain is found for the first 
    /// @notice non-errored randomize request posted on or after the given block number.
    function isRandomized(uint256 _evmBlockNumber)
        public view
        virtual override
        returns (bool)
    {
        return (
            getRandomizeStatus(_evmBlockNumber) == RandomizeStatus.Ready
        );
    }

    /// @notice Generates a pseudo-random number uniformly distributed within the range [0 .. _range), by using 
    /// the given `nonce` and the randomness returned by `fetchRandomnessAfter(blockNumber)`. 
    ///
    /// @dev Fails under same conditions as `fetchRandomnessAfter(uint256)` does.
    ///
    /// @param _range Range within which the uniformly-distributed random number will be generated.
    /// @param _nonce Nonce value enabling multiple random numbers from the same randomness value.
    /// @param _evmBlockNumber Block number from which the search for the first randomize request solved aftewards will start.
    function random(uint32 _range, uint256 _nonce, uint256 _evmBlockNumber)
        external view 
        virtual override
        returns (uint32)
    {
        return Witnet.randomUniformUint32(
            _range,
            _nonce,
            keccak256(
                abi.encode(
                    msg.sender,
                    fetchRandomnessAfter(_evmBlockNumber)
                )
            )
        );
    }

    /// @notice Requests the Witnet blockchain to generate an unbiased 256-bit random seed.
    /// @dev Only one randomize request per block will get ultimately relayed to the Witnet blockchain.
    /// @return EVM funds actually paid as randomize fee.
    function randomize()
        external payable
        virtual override
        returns (uint256)
    {
        return __postRandomizeQuery(__witOracleDefaultQueryParams);
    }

    /// @notice Requests the Witnet blockchain to generate an unbiased 256-bit random seed, complying with 
    /// the given SLA parameters.
    /// @dev Only one randomize request per block will get ultimately relayed to Witnet. Reverts if the
    /// given parameters do not comply with the `IWitRandomnessAdmin.witOracleRequiredParams()` limits.
    /// @param _witnetCommitteeSize Number of witnesses that will contribute to generate unbiased randomness.
    /// @param _witnetInclusionFees Minimum amount of nanoWits to be paid for including request on the Witnet blockchain.
    /// @return Funds actually paid as randomize fee.
    function randomize(
            uint16 _witnetCommitteeSize,
            uint64 _witnetInclusionFees
        )
        external payable
        virtual override
        returns (uint256)
    {
        return __postRandomizeQuery(_intoQuerySLA(
            _witnetCommitteeSize, 
            _witnetInclusionFees
        ));
    }


    /// ===============================================================================================================
    /// --- 'IWitRandomnessAdmin' implementation -------------------------------------------------------------------

    function acceptOwnership()
        virtual override (IWitRandomnessAdmin, Ownable2Step)
        public
    {
        Ownable2Step.acceptOwnership();
    }

    function baseFeeOverheadPercentage()
        virtual override
        external view 
        returns (uint16)
    {
        return __witOracleBaseFeeOverheadPercentage;
    }

    function owner()
        virtual override (IWitRandomnessAdmin, Ownable)
        public view 
        returns (address)
    {
        return Ownable.owner();
    }

    function pendingOwner() 
        virtual override (IWitRandomnessAdmin, Ownable2Step)
        public view
        returns (address)
    {
        return Ownable2Step.pendingOwner();
    }
    
    function transferOwnership(address _newOwner)
        virtual override (IWitRandomnessAdmin, Ownable2Step)
        public 
        onlyOwner
    {
        Ownable.transferOwnership(_newOwner);
    }

    function settleBaseFeeOverheadPercentage(uint16 _baseFeeOverheadPercentage)
        virtual override
        external
        onlyOwner
    {
        __witOracleBaseFeeOverheadPercentage = _baseFeeOverheadPercentage;
    }

    function settleWitOracleRequiredParams(IWitRandomnessAdmin.WitParams calldata _requiredWitParams)
        virtual override
        external
        onlyOwner
    {
        // validate ranges:
        _require(
            _requiredWitParams.minWitInclusionFees > 0
                && _requiredWitParams.minWitCommitteeSize > 0,
            "invalid ranges"
        );
        __storage().requiredWitParams = _requiredWitParams;
        
        // adapt default query sla params according to new randomize param ranges:
        if (_requiredWitParams.minWitCommitteeSize > __witOracleDefaultQueryParams.witCommitteeSize) {
            __witOracleDefaultQueryParams.witCommitteeSize = _requiredWitParams.minWitCommitteeSize;
        }
        __witOracleDefaultQueryParams.witUnitaryReward = _requiredWitParams.minWitInclusionFees;
    }

    /// @notice Admitted ranges when randomizing with specific security and liveness parameters.
    function witOracleRequiredParams() external view override returns (IWitRandomnessAdmin.WitParams memory) {
        return __storage().requiredWitParams;
    }


    // ================================================================================================================
    // --- Internal methods -------------------------------------------------------------------------------------------

    function _fetchRandomnessAfter(uint256 _evmBlockNumber)
        virtual internal view 
        returns (bytes32)
    {
        return __witOracle.getQueryResult(Witnet.QueryId.unwrap(
            _fetchRandomizeValidResultQueryId(_evmBlockNumber)
        )).fetchBytes32();
    }

    function _fetchRandomizeValidResultQueryId(uint256 _evmBlockNumber)
        virtual internal view 
        returns (Witnet.QueryId _queryId)
    {
        if (__storage().randomize_[_evmBlockNumber].queryId.isZero()) {
            _evmBlockNumber = getRandomizeNextBlock(_evmBlockNumber);
        }
        Randomize storage __data = __storage().randomize_[_evmBlockNumber];
        _queryId = __data.queryId;
        if (_queryId.isZero()) {
            _revert("not randomized");
        } 
        Witnet.ResultStatus _status  = __witOracle.getQueryResultStatus(Witnet.QueryId.unwrap(_queryId));
        if (_status.keepWaiting()) {
            _revert(string(abi.encodePacked(
                "pending randomize on block #",
                Witnet.toString(_evmBlockNumber)
            )));
        
        } else if (_status.hasErrors()) {
            uint256 _nextRandomizeBlock = __data.nextEvmBlock;
            _require(
                _nextRandomizeBlock != 0, 
                string(abi.encodePacked(
                    "faulty randomize on block #",
                    Witnet.toString(_evmBlockNumber)
                ))
            );
            return _fetchRandomizeValidResultQueryId(_nextRandomizeBlock);
        }
    }

    function _intoQuerySLA(
            uint16 _witCommitteeSize, 
            uint64 _witInclusionFees
        )
        internal view 
        returns (Witnet.QuerySLA memory)
    {
        IWitRandomnessAdmin.WitParams memory _requiredWitParams = __storage().requiredWitParams;
        if (_witCommitteeSize < _requiredWitParams.minWitCommitteeSize) {
            _revert("unsecure randomize");
        
        } else if (_witInclusionFees < _requiredWitParams.minWitInclusionFees) {
            _revert("poor incentives");
        
        } else {
            return Witnet.QuerySLA({
                witResultMaxSize: _WIT_QUERY_MAX_RESULT_SIZE,
                witCommitteeSize: _witCommitteeSize,
                witUnitaryReward: _witInclusionFees
            });
        }
    }

    function __postRandomizeQuery(Witnet.QuerySLA memory _querySLA)
        internal
        returns (uint256 _evmUsedFunds)
    {
        uint256 _queryId;
        uint256 _evmBlockNumber = block.number;
        if (__storage().lastRandomizeBlock < _evmBlockNumber) {
            _evmUsedFunds = msg.value;
            
            // Post the Witnet Randomness request:
            _queryId = __witOracle.queryData{
                value: msg.value
            }(
                __witOracleQueryRadonHash,
                _querySLA
            );

            // Save Randomize metadata in storage:
            uint256 _prevBlock = __storage().lastRandomizeBlock;
            Randomize storage __randomize = __storage().randomize_[_evmBlockNumber];
            __randomize.queryId = Witnet.QueryId.wrap(uint64(_queryId));
            __randomize.prevEvmBlock = uint96(_prevBlock);
            __storage().randomize_[_prevBlock].nextEvmBlock = uint96(_evmBlockNumber);
            __storage().lastRandomizeBlock = _evmBlockNumber;
        
        } else {
            _queryId = Witnet.QueryId.unwrap(__storage().randomize_[_evmBlockNumber].queryId);
        }

        // Transfer back unused funds:
        if (_evmUsedFunds < msg.value) {
            payable(msg.sender).transfer(msg.value - _evmUsedFunds);
        }

        // Emit event upon every randomize call, even if multiple within same block:
        // solhint-disable-next-line avoid-tx-origin
        emit Randomizing(tx.origin, _msgSender(), Witnet.QueryId.wrap(uint64(_queryId)));
    }

    /// @dev Recursively searches for the number of the first block after the given one in which a Witnet 
    /// @dev randomness request was posted. Returns 0 if none found.
    function _searchNextBlock(uint256 _target, uint256 _latest) internal view returns (uint256) {
        return (_target >= _latest 
            ? __storage().randomize_[_latest].nextEvmBlock
            : _searchNextBlock(_target, __storage().randomize_[_latest].prevEvmBlock)
        );
    }

    /// @dev Recursively searches for the number of the first block before the given one in which a Witnet 
    /// @dev randomness request was posted. Returns 0 if none found.
    function _searchPrevBlock(uint256 _target, uint256 _latest) internal view returns (uint256) {
        return (_target > _latest
            ? _latest
            : _searchPrevBlock(_target, __storage().randomize_[_latest].prevEvmBlock)
        );
    }

    bytes32 private constant _STORAGE_SLOT = 
        // keccak256("io.witnet.apps.randomness.v21")
        0xad347e0aa7977751e064b632bb66fc0bf1ba5efb89904260ebcdf6f008718e67;

    function __storage() internal pure returns (Storage storage _ptr) {
        assembly {
            _ptr.slot := _STORAGE_SLOT
        }
    }
}
