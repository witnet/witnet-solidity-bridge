// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import "../WitRandomness.sol";

import "../interfaces/IWitOracle.sol";
import "../interfaces/IWitOracleQueriable.sol";
import "../interfaces/IWitRandomnessAdmin.sol";

import "../patterns/Ownable2Step.sol";

/// @title WitRandomnessV3: Unbiased, EVM-agnostic and provably-fair random seeds from the Witnet blockchain. 
/// 
/// 64-bit entropy seeds can be permissionless pulled at anytime from smart contracts and externally-owned EVM accounts.
/// 
/// Randomness provisioning is securely protected against race-condition and malleability attacks by node validators
/// on both EVM and Witnet blockchains. 
///
/// This contract acts also as a public-good registry, openly preserving all random seeds generated in the past,
/// and providing after-the-fact traceability proof to the actual witnessing committees and punishable acts that took
/// place on the Witnet blockchain for generating every single one of them.
///
/// @dev Protection against race-condition and malleability attacks requires randomness queried to this contract
/// to be solved is an asynchronous way, meaning that after some randomness is requested, the result provided
/// from the Wit/Oracle sidechain won't be ready until a certain amount of EVM blocks have elapsed. 
/// This protection also implies that eventually failing randomness requests on the Wit/Oracle sidechain 
/// cannot be retried but from this very same contract. Failing randomness requests will get all automatically
/// and unbiasedly solved as soon as some new randomness request gets solved, even if paid by a different requester.
///
/// Querying for new randomness requires paying a fee in native EVM gas currency, as to cover the implicit cost of
/// solving unmalleable randomness on the Wit/Oracle sidechain and report it back to the EVM storage. The actual 
/// randomize fee depends on the expected gas price to pay for the EVM transaction that would eventually include 
/// a call to any of the `randomize(..)` methods of this contract. The randomize fee can be computed by passing
/// the expected gas price value to the `estimateRandomizeFee(uint256)` method.
///
/// > Note [1]: On highly volatile gas price markets, especially on some Layer-2 EVM chains, is highly recommended
/// to estimate the randomize fee before a `randomize()` call, and pass a fresh EVM gas price value. Otherwise
/// the call to `randomize()` could potentially revert with either "insufficient reward" or "too much reward".
///
/// > Note [2]: Contracts requiring "synchronous" randomness resolution (e.g. minting NFTs) as to avoid
/// involving end users in two-phase operations, might rather prefer to inherit from the 
/// `WitOracleQueriableRandomnessConsumer` abstract class instead of relying on this contract. Nevertheless,
/// they would have to deal themselves with eventual randomness resolution errors.
///
/// @author Guillermo DÃ­az <guillermo@witnet.io>
contract WitRandomnessV3
    is
        Ownable2Step,
        WitRandomness,
        IWitRandomnessAdmin
{
    // using Witnet for bytes;
    // using Witnet for uint64;
    using Witnet for Witnet.DataResult;
    // using Witnet for Witnet.QueryId;
    // using Witnet for Witnet.QuerySLA;
    // using Witnet for Witnet.ResultStatus;

    struct Randomize {
        uint64 queryId;
        uint64 finality;
        uint64 nextBlock;
        bytes8 randomness;
        uint64 prevBlock;
    }

    struct Storage {
        uint64  lastRandomizeBlock;
        mapping (Witnet.QueryId => uint256) blocks;
        mapping (uint256 => Randomize) requests;
        Settings settings;
    }
    
    /// @notice Unique identifier of the RNG data request used on the Witnet blockchain for solving randomness.
    /// @dev Can be used to track all randomness requests solved so far on the Witnet blockchain.
    Witnet.RadonHash internal immutable __WIT_ORACLE_RNG_RADON_HASH;

    /// @dev Size of successful CBOR-encoded randomness generated by the Witnet blockchain. 
    uint16 internal constant _WIT_ORACLE_RNG_MAX_RESULT_SIZE = 34;

    /// @dev Minimum of amount of passing blocks before considering a randomize request to be delayed.
    uint16 internal constant _MIN_RANDOMIZE_WAITING_BLOCKS = 2;

    address immutable public override witOracle;

    constructor(
            address _witOracle,
            address _operator
        )
        Ownable(_operator)
    {
        _require(
            _witOracle.code.length > 0
                && IWitAppliance(_witOracle).specs() == (
                    type(IWitOracle).interfaceId
                        ^ type(IWitOracleQueriable).interfaceId
                ), 
            "uncompliant WitOracle"
        );
        witOracle = _witOracle;

        // Build Witnet-compliant randomness request:
        IWitOracleRadonRegistry _witOracleRadonRegistry = IWitOracle(_witOracle).registry();
        __WIT_ORACLE_RNG_RADON_HASH = _witOracleRadonRegistry.verifyRadonRequest(
            Witnet.intoMemArray([
                _witOracleRadonRegistry.verifyRadonRetrieval(
                    Witnet.RadonRetrievalMethods.RNG,
                    "", // no request url
                    "", // no request body
                    new string[2][](0), // no request headers
                    hex"80" // no request Radon script
                )
            ]),
            Witnet.RadonReducer({
                opcode: Witnet.RadonReduceOpcodes.Mode,
                filters: new Witnet.RadonFilter[](0)
            }),
            Witnet.RadonReducer({
                opcode: Witnet.RadonReduceOpcodes.ConcatenateAndHash,
                filters: new Witnet.RadonFilter[](0)
            })
        );

        // Initialize settings:
        __storage().settings = Settings({
            feeOverheadPercentage: 10,
            maxCallbackGasLimit: 50000,
            minWitCommitteeSize: 3,
            minWitInclusionFees: 166666666,
            randomizeWaitingBlocks: 256
        });
    }

    receive() virtual external payable {
        _revert("no transfers accepted");
    }

    fallback() virtual external payable { 
        _revert(string(abi.encodePacked(
            "not implemented: 0x",
            Witnet.toHexString(uint8(bytes1(msg.sig))),
            Witnet.toHexString(uint8(bytes1(msg.sig << 8))),
            Witnet.toHexString(uint8(bytes1(msg.sig << 16))),
            Witnet.toHexString(uint8(bytes1(msg.sig << 24)))
        )));
    }

    function class() virtual override public pure returns (string memory) {
        return type(WitRandomnessV3).name;
    }

    
    /// ===============================================================================================================
    /// --- IWitRandomness ------------------------------------------------------------------------------------------

    /// Returns amount of wei required to be paid as a fee when requesting randomization with a 
    /// transaction gas price as the one given.
    function estimateRandomizeFee(uint256 _evmGasPrice)
        public view
        virtual override
        returns (uint256)
    {
        return (
            IWitOracleQueriable(witOracle).estimateBaseFeeWithCallback(
                _evmGasPrice, 
                __storage().settings.maxCallbackGasLimit
            ) * (100 + __storage().settings.feeOverheadPercentage)
        ) / 100;
    }

    /// Retrieves the result of keccak256-hashing the given block number with the randomness value 
    /// generated by the Witnet blockchain in response to the first non-failing randomize request solved 
    /// after such block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on neither the given block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the given block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the given block were solved with errors.
    ///
    /// @param _blockNumber Block number from which the search will start.
    function fetchRandomnessAfter(uint256 _blockNumber)
        public view
        virtual override
        returns (bytes32)
    {
        return keccak256(
            abi.encode(
                _blockNumber,
                _fetchRandomnessAfter(_blockNumber)
            )
        );
    }
    
    /// Retrieves the actual random value, unique hash and timestamp of the witnessing commit/reveal act 
    /// that took place in the Witnet blockchain in response to the first non-failing randomize query
    /// solved after the given block number.
    ///
    /// @dev Reverts if:
    ///    i.   no `randomize()` was queried on neither the given block, nor afterwards.
    ///    ii.  the first non-failing `randomize()` request found on or after the given block is not solved yet.
    ///    iii. all `randomize()` requests that took place on or after the given block were solved with errors.
    ///
    /// @param _blockNumber Block number from which the search will start.
    ///
    /// @return _witnetQueryUUID Universal identifier of the query posted from this contract that ultimately solved randomness.
    /// @return _witnetTimestamp Timestamp at which the randomness value was generated by the Witnet blockchain.
    /// @return _witnetDrTxHash Hash of the witnessing commit/reveal act that took place on the Witnet blockchain.
    /// @return _evmFinalityBlock EVM block number at which the generated randomness can be considered to be final.
    function fetchRandomnessAfterTrails(uint256 _blockNumber) 
        virtual override
        public view 
        returns (
            bytes32 _witnetQueryUUID,
            Witnet.Timestamp _witnetTimestamp,
            Witnet.TransactionHash _witnetDrTxHash,
            uint256 _evmFinalityBlock
        )
    {
        (_witnetQueryUUID, _witnetDrTxHash, _witnetTimestamp, _evmFinalityBlock) = IWitOracleQueriable(witOracle)
            .getQueryResultTrails(
                _getRandomizeQueryId(_blockNumber)
            );
    }

    /// Returns last block number on which a randomize was requested.
    function getLastRandomizeBlock()
        virtual override
        external view
        returns (uint256)
    {
        return __storage().lastRandomizeBlock;
    }

    /// Retrieves metadata related to the randomize request that got queried to the`WitOracle` contract 
    /// on the specified block number, if any.
    ///
    /// @dev Returns zero values if no randomize request was actually queried on the specified block number.
    ///
    /// @param _blockNumber Block number from which the search will start.
    ///
    /// @return _queryId Identifier of the underlying Wit/Oracle query created on the specified block number. 
    /// @return _prevRandomizeBlock Block number in which a randomize request got queried just before this one. 0 if none.
    /// @return _nextRandomizeBlock Block number in which a randomize request got queried just after this one, 0 if none.
    function getRandomizeData(uint256 _blockNumber)
        external view
        virtual override
        returns (
            Witnet.QueryId _queryId,
            uint256 _prevRandomizeBlock,
            uint256 _nextRandomizeBlock
        )
    {
        Randomize storage __request = __storage().requests[_blockNumber];
        _queryId = Witnet.QueryId.wrap(__request.queryId);
        _prevRandomizeBlock = __request.prevBlock != 0 ? __request.prevBlock : getRandomizePrevBlock(_blockNumber);
        _nextRandomizeBlock = __request.nextBlock != 0 ? __request.nextBlock : getRandomizeNextBlock(_blockNumber);
    }

    /// Returns security and liveness parameters required to the Witnet blockchain 
    /// when solving randomness requests, if no others are specified.
    /// @return _witCommitteeSize Number of Witnet witnessing nodes required to generate unbiased randomness.
    /// @return _witInclusionFees Minimum amount of fees in $nanoWIT to be paid on the Witnet blockchain.
    /// @return _callbackGasLimit Max. expendable gas upon randomness delivery (applies only on soulbound clones).
    function getRandomizeDefaultParams()
        virtual override
        public view
        returns (
            uint16 _witCommitteeSize,
            uint64 _witInclusionFees,
            uint24 _callbackGasLimit
        )
    {
        Settings storage __settings = __storage().settings;
        return (
            __settings.minWitCommitteeSize,
            __settings.minWitInclusionFees,
            __settings.maxCallbackGasLimit
        );
    }

    /// Returns the number of the next block in which a randomize request was posted after the given one. 
    /// @param _blockNumber Block number from which the search will start.
    /// @return Number of the first block found after the given one, or `0` otherwise.
    function getRandomizeNextBlock(uint256 _blockNumber)
        public view
        virtual override
        returns (uint256)
    {
        return (
            __storage().requests[_blockNumber].queryId == 0
                ? _searchNextBlock(_blockNumber, __storage().lastRandomizeBlock)
                : __storage().requests[_blockNumber].nextBlock
        );
    }

    /// Returns the number of the previous block in which a randomize request was posted before the given one.
    /// @param _blockNumber Block number from which the search will start. Cannot be zero.
    /// @return First block found before the given one, or `0` otherwise.
    function getRandomizePrevBlock(uint256 _blockNumber)
        public view
        virtual override
        returns (uint256)
    {
        uint256 _latest = __storage().lastRandomizeBlock;
        return (_blockNumber > _latest
            ? _latest
            // start search from the latest block
            : _searchPrevBlock(_blockNumber, __storage().requests[_latest].prevBlock)
        );
    }

    /// Returns the identifier of the Wit/Oracle query that has either solved randomness
    /// for the specified block number, is currently attending randomness for the specified block number,
    /// of the one that attempted to solve it. 
    /// @dev Returns zero if no randomize was request on or after the specified block number.
    function getRandomizeQueryId(uint256 _blockNumber)
        virtual override
        public view
        returns (Witnet.QueryId)
    {
        return Witnet.QueryId.wrap(
            _getRandomizeQueryId(_blockNumber)
        );
    }

    /// Explains why the last attempt of generating randomness for the specified block number failed.
    function getRandomizeQueryErrorDescription(uint256 _blockNumber) 
        virtual override 
        public view
        returns (string memory _reason)
    {
        RandomizeStatus _status = getRandomizeStatus(_blockNumber);
        if (_status == RandomizeStatus.Error) {
            _reason = IWitOracleQueriable(witOracle).getQueryResultStatusDescription(
                _getRandomizeQueryId(_blockNumber)
            );
        }
    }

    /// Returns the immutable bytecode of the Radon Request that's being used 
    /// for solving randomness requests on the Witnet blockchain.
    function getRandomizeRadonBytecode() virtual override external view returns (bytes memory) {
        return IWitOracle(witOracle).registry().lookupRadonRequestBytecode(
            getRandomizeRadonHash()
        );
    }

    /// Returns the unique identifier of the Radon Request that's being used 
    /// for solving request randomness requests on the Witnet blockchain.
    function getRandomizeRadonHash() virtual override public view returns (Witnet.RadonHash) {
        return __WIT_ORACLE_RNG_RADON_HASH;
    }

    /// Returns status of the first non-errored randomize request queried on or after the given block number.
    ///  - 0 -> Void: no randomize request was actually queried on or after the given block number.
    ///  - 1 -> Awaiting: a randomize request was found but it's not yet solved by the Wit/Oracle.
    ///  - 2 -> Ready: a successfull randomize value was reported and is ready to be read.
    ///  - 3 -> Error: all attempted randomize requests at or after the given block were solved with errors.
    ///  - 4 -> Finalizing: a randomize result was relayed already but cannot yet be considered to be final.
    function getRandomizeStatus(uint256 _blockNumber)
        virtual override
        public view 
        returns (RandomizeStatus)
    {
        Randomize storage __request = __storage().requests[_blockNumber];
        Settings storage __settings = __storage().settings;

        if (_blockNumber == 0) {
            return RandomizeStatus.Void;
        
        } else if (__request.queryId == 0) {
            // if no randomize was requested on the specified block number, 
            // return the current status of the first randomize request after it, if any:
            return getRandomizeStatus(
                getRandomizeNextBlock(_blockNumber)
            );
        
        } else if (__request.queryId == type(uint64).max) {
            // if the resolution to the randomize request on the specified block number failed,
            // return the current status of the randomize request after it, if any, 
            // or `Error` otherwise:
            if (__request.nextBlock > 0) {
                return getRandomizeStatus(__request.nextBlock);
            } else {
                return RandomizeStatus.Error;
            }
        
        } else {
            if (__request.randomness == bytes32(0)) {
                // if there was a randomize request on the specified block number,
                // but it hasn't been solved after some settled number of blocks,
                // return the current status of the later randomize request if any,
                // or still `Awaiting` otherwise:
                if (
                    block.number > _blockNumber + __settings.randomizeWaitingBlocks
                        && __request.nextBlock > 0
                ) {
                    return getRandomizeStatus(__request.nextBlock);
                } else {
                    return RandomizeStatus.Awaiting;
                }
            
            } else {
                // if there was a randomize request on the specified block number,
                // and it has already been resolved, return `Ready` or `Finalizing` depending 
                // on whether the randomness finality block has already been reached:
                return (
                    block.number >= __request.finality
                        ? RandomizeStatus.Ready
                        : RandomizeStatus.Finalizing
                );
            }
        }
    }


    /// Returns `true` only if a successfull resolution from the Witnet blockchain is found for the first 
    /// non-errored randomize request posted on or after the given block number.
    function isRandomized(uint256 _blockNumber)
        public view
        virtual override
        returns (bool)
    {
        return (
            getRandomizeStatus(_blockNumber) == RandomizeStatus.Ready
        );
    }

    /// Requests the Witnet blockchain to generate an unbiased 256-bit random seed.
    /// @dev Only one randomize request per block will get ultimately relayed to the Witnet blockchain.
    /// @return EVM funds actually paid as randomize fee.
    function randomize()
        external payable
        virtual override
        returns (uint256)
    {
        return __randomize(__storage().settings.minWitCommitteeSize);
    }

    /// Requests the Witnet blockchain to generate an unbiased 256-bit random seed, complying with 
    /// the given SLA parameters.
    /// @dev Only one randomize request per block will get ultimately relayed to Witnet. Reverts if the
    /// given parameters do not comply with the `IWitRandomnessAdmin.witOracleRequiredParams()` limits.
    /// @param _witnetCommitteeSize Number of witnesses that will contribute to generate unbiased randomness.
    /// @return Funds actually paid as randomize fee.
    function randomize(uint16 _witnetCommitteeSize)
        external payable
        virtual override
        returns (uint256)
    {
        _require(
            _witnetCommitteeSize >= __storage().settings.minWitCommitteeSize,
            "unsecure randomize"
        );
        return __randomize(_witnetCommitteeSize);
    }

    /// Verifies that the specified randomness seed was actually generated on the Witnet blockchain,
    /// and was actually used for producing the randomness seed returned by `fetchRandomnessAfter`.
    function verifyRandomnessAfter(uint256 blockNumber, bytes32 witnetRandomness)
        external view 
        virtual override
        returns (bool)
    {
        return (
            isRandomized(blockNumber)
                && fetchRandomnessAfter(blockNumber) == keccak256(abi.encode(
                    blockNumber,
                    bytes8(witnetRandomness)
                ))
        );
    }


    /// ===============================================================================================================
    /// --- IWitRandomnessAdmin -------------------------------------------------------------------------------------

    function acceptOwnership()
        virtual override (IWitRandomnessAdmin, Ownable2Step)
        public
    {
        Ownable2Step.acceptOwnership();
    }

    function owner()
        virtual override (IWitRandomnessAdmin, Ownable)
        public view 
        returns (address)
    {
        return Ownable.owner();
    }

    function pendingOwner() 
        virtual override (IWitRandomnessAdmin, Ownable2Step)
        public view
        returns (address)
    {
        return Ownable2Step.pendingOwner();
    }
    
    function transferOwnership(address _newOwner)
        virtual override (IWitRandomnessAdmin, Ownable2Step)
        public 
        onlyOwner
    {
        Ownable.transferOwnership(_newOwner);
    }

    function settings() virtual override external view returns (Settings memory) {
        return __storage().settings;
    }

    function settleFeeOverheadPercentage(uint16 _feeOverheadPercentage)
        virtual override
        external
        onlyOwner
    {
        __storage().settings.feeOverheadPercentage = _feeOverheadPercentage;
    }

    function settleQueryDefaultParams(
            uint16 _minWitCommitteeSize,
            uint64 _minWitInclusionFees,
            uint24 _minCallbackGasLimit
        )
        virtual override
        external
        onlyOwner
    {
        Settings storage __settings = __storage().settings;
        // validate ranges:
        _require(
            _minWitCommitteeSize > 0 
                && _minWitCommitteeSize <= 127
                && _minWitInclusionFees > 0
                && _minCallbackGasLimit > 0,
            "invalid ranges"
        );
        
        __settings.minWitCommitteeSize = _minWitCommitteeSize;
        __settings.minWitInclusionFees = _minWitInclusionFees;
        __settings.maxCallbackGasLimit = _minCallbackGasLimit;
    }

    function settleRandomizeWaitingBlocks(uint16 _randomizeWaitingBlocks)
        virtual override
        external
        onlyOwner
    {
        _require(_randomizeWaitingBlocks >= _MIN_RANDOMIZE_WAITING_BLOCKS, "too few");
        __storage().settings.randomizeWaitingBlocks = _randomizeWaitingBlocks;
    }


    // ================================================================================================================
    // --- IWitOracleQueriableConsumer --------------------------------------------------------------------------------

    /// Method to be called from the witOracle contract as soon as the given Witnet `queryId` gets reported.
    /// @dev It should revert if called from an address different to the WitOracle instance being used by consumer.
    /// @param queryId The unique identifier of the Witnet query being reported.
    /// @param queryResult Abi-encoded Witnet.DataResult containing the CBOR-encoded query's result, and metadata.
    function reportWitOracleQueryResult(
            uint256 queryId,
            bytes calldata queryResult
        ) 
        virtual override
        external
    {
        uint256 _randomizeBlock = __storage().blocks[Witnet.QueryId.wrap(uint64(queryId))];
        _require(_randomizeBlock > 0, "invalid query");
        _require(reportableFrom(msg.sender), "invalid oracle");

        Randomize storage __request = __storage().requests[_randomizeBlock];

        Witnet.DataResult memory _queryResult = abi.decode(queryResult, (Witnet.DataResult));
        if (
            __request.randomness == 0
                && block.number > _randomizeBlock + __storage().settings.randomizeWaitingBlocks
                && __request.nextBlock > 0
        ) {
            // ignore the query result if it's provided too late and there was a later randomize attempt:
            __request.queryId = type(uint64).max;

        } else {
            if (_queryResult.status == Witnet.ResultStatus.NoErrors) {
                if (uint64(queryId) != __request.queryId) {
                    // if a non-finalized error was disputed and eventually won:
                    __request.queryId = uint64(queryId);
                }
                __request.randomness = bytes8(_queryResult.fetchBytes32());
        
            } else {
                __request.queryId = type(uint64).max;
                __request.randomness = bytes8(0);
            }
            __request.finality = uint64(_queryResult.finality);

            emit Randomized(
                _randomizeBlock, 
                _queryResult.finality,
                __request.randomness
            );
        }
    }

    /// Determines if Witnet queries can be reported from given address.
    /// @dev In practice, must only be true on the WitOracle address that's being used by
    /// @dev the consumer contract to post data queries. 
    function reportableFrom(address _from) 
        virtual override 
        public view 
        returns (bool)
    {
        return (
            _from == address(witOracle)
        );
    }

    
    // ================================================================================================================
    // --- Internal methods -------------------------------------------------------------------------------------------

    function _getRandomizeQueryId(uint256 _blockNumber)
        virtual internal view 
        returns (uint64)
    {
        Randomize storage __request = __storage().requests[_blockNumber];
        Settings storage __settings = __storage().settings;

        if (__request.queryId == 0) {
            return _getRandomizeQueryId(
                getRandomizeNextBlock(_blockNumber)
            );

        } else if (__request.queryId == type(uint64).max) {
            return (
                __request.nextBlock > 0 
                    ? _getRandomizeQueryId(__request.nextBlock) 
                    : __request.queryId
            );
        
        } else {
            if (__request.randomness == bytes8(0)) {
                if (
                    block.number > _blockNumber + __settings.randomizeWaitingBlocks
                        && __request.nextBlock > 0
                ) {
                    return _getRandomizeQueryId(__request.nextBlock);
                }
            }
            return __request.queryId;
        }
    }

    function _fetchRandomnessAfter(uint256 _blockNumber)
        virtual internal view 
        returns (bytes8 _randomness)
    {
        Randomize storage __request = __storage().requests[_blockNumber];
        if (__request.queryId == 0) {
            return _fetchRandomnessAfter(
                getRandomizeNextBlock(_blockNumber)
            );
        
        } else if (__request.queryId == type(uint64).max) {
            _require(
                __request.nextBlock > 0,
                "failed: retry randomize"
            );
            return _fetchRandomnessAfter(
                __request.nextBlock
            );
        
        } else if (__request.randomness == bytes8(0)) {
            if (block.number > _blockNumber + __storage().settings.randomizeWaitingBlocks) {
                _require(
                    __request.nextBlock > 0,
                    "delayed: keep waiting or retry randomize"
                );
                return _fetchRandomnessAfter(__request.nextBlock);
            } else {
                _revert("pending randomize");
            }
        
        } else {
            _require(
                block.number >= __request.finality,
                string(abi.encodePacked(
                    "finalizing on block #",
                    Witnet.toString(uint256(__request.finality))
                ))
            );
            return __request.randomness;
        }
    }

    function __randomize(uint16 _witnetCommitteeSize)
        internal
        returns (uint256 _evmUsedFunds)
    {
        uint256 _queryId;
        uint256 _blockNumber = block.number;
        if (__storage().lastRandomizeBlock < _blockNumber) {
            _evmUsedFunds = msg.value;
            
            // Post the Witnet Randomness request:
            _queryId = IWitOracleQueriable(witOracle).queryDataWithCallback{
                value: msg.value
            }(
                __WIT_ORACLE_RNG_RADON_HASH,
                Witnet.QuerySLA({
                    witResultMaxSize: _WIT_ORACLE_RNG_MAX_RESULT_SIZE,
                    witCommitteeSize: _witnetCommitteeSize,
                    witUnitaryReward: __storage().settings.minWitInclusionFees
                }),
                Witnet.QueryCallback({
                    consumer: address(this),
                    gasLimit: __storage().settings.maxCallbackGasLimit
                })
            );

            // Save Randomize metadata in storage:
            uint256 _prevBlock = __storage().lastRandomizeBlock;
            Randomize storage __request = __storage().requests[_blockNumber];
            __request.queryId = uint64(_queryId);
            __request.prevBlock = uint64(_prevBlock);
            __storage().requests[_prevBlock].nextBlock = uint64(_blockNumber);
            __storage().lastRandomizeBlock = uint64(_blockNumber);
            __storage().blocks[Witnet.QueryId.wrap(uint64(_queryId))] = _blockNumber;

            // Emit event only on first successful randomize within one block:
            // solhint-disable-next-line avoid-tx-origin
            emit Randomizing(
                _msgSender(), 
                Witnet.QueryId.wrap(uint64(_queryId))
            );
        
        } else {
            _queryId = __storage().requests[_blockNumber].queryId;
        }

        // Transfer back unused funds:
        if (_evmUsedFunds < msg.value) {
            payable(msg.sender).transfer(msg.value - _evmUsedFunds);
        }
    }

    /// @dev Recursively searches for the number of the first block after the given one in which a Witnet 
    /// @dev randomness request was posted. Returns 0 if none found.
    function _searchNextBlock(uint256 _target, uint256 _latest) internal view returns (uint256) {
        return (_target >= _latest 
            ? __storage().requests[_latest].nextBlock
            : _searchNextBlock(_target, __storage().requests[_latest].prevBlock)
        );
    }

    /// @dev Recursively searches for the number of the first block before the given one in which a Witnet 
    /// @dev randomness request was posted. Returns 0 if none found.
    function _searchPrevBlock(uint256 _target, uint256 _latest) internal view returns (uint256) {
        return (_target > _latest
            ? _latest
            : _searchPrevBlock(_target, __storage().requests[_latest].prevBlock)
        );
    }

    bytes32 private constant _STORAGE_SLOT = 
        // keccak256("io.witnet.apps.randomness.v3") & ~bytes32(uint256(0xff) 
        0x43025ad356942e949bc1eab02ffb42d0642f59c8829febfec0169ebcda390700;

    function __storage() internal pure returns (Storage storage _ptr) {
        assembly {
            _ptr.slot := _STORAGE_SLOT
        }
    }
}
